# BSM1_cn

将Modelica模型(BSM1)转换为Python OpenAI Gym环境，并使用人工智能的强化学习代理优化操作成本。

本README提供了关于如何:

1. 使用[Open Modelica](https://www.openmodelica.org/)从Python ([OMPython](https://github.com/OpenModelica/OMPython))运行Modelica模型

2. 将模型转换为[FMU](https://fmi-standard.org/)格式，并使用[PyFMI](https://github.com/modelon-community/PyFMI)在Python中直接模拟它。

3. 为FMU创建一个OpenAI环境，并使用强化学习代理与模型交互

这里的代码是用来模拟[污水处理厂ASM1号](https://www.iea.lth.se/publications/Reports/LTH-IEA-7229.pdf) (BSM1)的Modelica实现的，可以在这个资源库中的[./WasteWaterResearch/BSM1/](./ wasteresearch /BSM1/)目录中找到它，它改编自[Félix Hernández del Olmo](https://github.com/felixhdelolmo/WasteWaterResearch)的工作。此外，它的编译FMU已经在这个存储库中可用([BSM1.BSM1.fmu](./BSM1.BSM1.fmu))，它可以直接在Windows 64位系统下使用(它是在这个存储库中编译的)，而不需要重新编译它(在任何情况下，生成FMU的指令已经包含在本README中)。最后，即使用户对BSM1不感兴趣，该存储库也提供了工具和说明，以适应任何Modelica模型，将其集成到OpenAI Gym API中，并用于在其上训练强化学习代理。

## 0.制备步骤
 - 下载并安装适用于 Python 3.7 的 Miniconda：https ://docs.conda.io/en/latest/miniconda.html
 - 安装后，打开 Anaconda 提示符，并创建 Modelica 环境：conda create -n modelica python=3.7
 - 激活它：conda activate modelica
 - 安装一些需要的库：
```{bash}
conda install numpy matplotlib psutil pyzmq scipy future git pandas seaborn scikit-learn tqdm
conda install -c conda-forge ffmpeg
```
 - 将此存储库克隆到您的计算机并导航到它：:
```{bash}
git clone https://github.com/OscarPellicer/BSM1_gym.git
cd BSM1_gym
```

## 1. Interacting with OpenModelica models through OMPython
 - Download and install OpenModelica: https://www.openmodelica.org/
 - To run Modelica models from Python (non-interactively), we can install and use the OMPython library:
 - Install: `python -m pip install -U https://github.com/OpenModelica/OMPython/archive/master.zip`
 - To see any plots generated by the code in the following sections, it is recommended to run the code within Jupyter Notebook / Jupyter lab.
 - To install Jupyter lab: `conda install jupyter jupyterlab`.
 - Then, run `jupyter notebook` in the console, and navigate to http://localhost:8888/lab. Then click on File > New > Notebook, and start coding!
 - We have created a simplified runner for OpenModelica commands in Python, `Runner`, which can be found in `utils.py`. Testing on the bouncing ball model:
```{python}
from utils import Runner
R= Runner()
R.run("loadModel(Modelica)")
R.run("loadFile(getInstallationDirectoryPath() + \"/share/doc/omc/testmodels/BouncingBall.mo\")")
R.run("instantiateModel(BouncingBall)")
R.run("simulate(BouncingBall, stopTime=3.0)")
```
 - This will generate a `.mat` output file that can be read with [DyMat](https://github.com/jraedler/DyMat), which has been included in this repository. Furthermore, class `MatHandler` uses DyMat to simplify the process of reading and plotting simulation results:
```{python}
from utils import MatHandler
m= MatHandler('BouncingBall_res.mat')
print('Variable names:', m.names)
m.plot(['h', 'v', 'der(v)'], plot_indep=False)
```
 
## 2.  Creating a FMU and simulating it using PyFMI
 - PyFMI allows to simulate FMUs in Python
 - Install `pyfmi`: `conda install -c conda-forge pyfmi` (note: if running jupyter lab, you will now need to open a new Anaconda terminal and actiavte the `modelica` environment, or close Jupyter)
 - Then, create the FMU from Python using OMPython:
```{python}
model_name= "BouncingBall"
R.run("loadModel(Modelica)")
R.run("loadFile(getInstallationDirectoryPath() + \"/share/doc/omc/testmodels/BouncingBall.mo\")")
R.run("instantiateModel(BouncingBall)")
R.run('translateModelFMU(%s, version="2.0", fmuType = "me")'%model_name)
```
 - And simualte it using PyFMI:
```{python}
from pyfmi import load_fmu
model= load_fmu('%s.fmu'%model_name)
res= model.simulate(final_time=3)
```

- We can do the same for our custom model
```{python}
# Create a FMU using OMPython
base_path= 'WasteWaterResearch'
model_name= 'BSM1.BSM1'
R.run('loadModel(Modelica,{"3.2.3"},true,"",false)')
R.run('loadFile("%s/WasteWater/package.mo","UTF-8",true,true,false)'%base_path)
R.run('loadFile("%s/BSM1/package.mo","UTF-8",true,true,false)'%base_path)
R.run('disableNewInstantiation()')
R.run('translateModelFMU(%s, version="2.0", fmuType = "me")'%model_name)

# Import PyFMI, set the options so that sparse solver is not used, and simulate
from pyfmi import load_fmu
model = load_fmu('%s.fmu'%model_name)
opts = model.simulate_options() 
opts["CVode_options"]["linear_solver"] = "DENSE"
res = model.simulate(final_time=1, options=opts)
```

- `pyFMI` allows an easy interface to the results, without having to read the generated `.mat` file:
```{python}
# To see the name of all variables
res.keys()
# To access the values of one of them
res['time']
# To access final value
res.final('time')
# To get the description
res.result_data.description[res.keys().index('time')]
```

## 3. Creating an OpenAI Gym environment and training a Reinforecement Learning agent on it
 - Install OpenAI Gym: `conda install -c conda-forge gym`
 - An example of setting up an environment (BSM1), and training an agent to optimize operation cost on it can be found in [Training.ipynb](Training.ipynb)
 - In order to use deep learning agents, you need to install pytorch too. It is also needed for running [Training.ipynb](Training.ipynb). You can follow the instructions here: https://pytorch.org/get-started/locally/
 - Obviously, to run the Notebook, Jupyter Notebook must be first installed (see [above](#interacting-with-openmodelica-models-through-ompython)).
 - Please note that BSM1 simulations can sometimes fail due to the agents making a series of actions that yield to division by zero within the model. This is a rare occourance that unfortunately has not yet been solved. If this happens, please rerun the simulation.
 - If you want to adapt the library to your own needs, you should first implement a class similar to `BSM1Env` found in `BSM1Envs/bsm1_env.py`. This class implements the `ModelicaEnv` class, which, in turn inherits from `gym.Env`, which is the parent class for all Gym environments.
 - You should also modify some of the variables in [Training.ipynb](Training.ipynb), such as `base_path`, `model_name`, `action_names`, `env_name`, `entry_point`, `output_names` to adapt them to your own model.
 - The rest of the Python files in the repository are used by [Training.ipynb](Training.ipynb), and provide the following functionality:
   - `agents.py`: This file contains the implementation of some of the most common Q-like agents, using
pytorch for the deep agents.
   - `wrappers.py`: This contains some useful wrappers for OpenAI environments to help integrate them
with different kinds of agents.
   - `training.py`: This file contains all the code for letting an agent interact and learn from the evironment
as well as to plot the evolution of the values of the variables over time.

This work is part of my end-of-degree project for my Computer Science degree at [UNED University](https://www.uned.es/), which can be found [in this repository](https://github.com/OscarPellicer/BSM1_gym/blob/main/TFG%20Oscar%20Jos%C3%A9%20Pellicer%20Valero.pdf) (in Spanish).
